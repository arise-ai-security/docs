# Research Sync 2025-11-21

**Attendees:** Caroline Cahill, In Keun Kim, Song Li

**Date:** 2025-11-21
---
## Tasks Moving Forward
1. **Reasoning:** Determine what our point-of-attack is on SEC-bench
    - ***End Goal:*** 
        - Run 50 instances with gpt-4o and gpt-5 and provide quantitative comparisons of the models' success rates
    - ***Intermediary Steps:***
        - Start with HwiwonLee's final commit
        - Run 3-5 instances with gpt-4o and gpt-5 and compare the conversations the models had.
            - Fix bugs to implement gpt-5 in the final commit
        - Check to see whether or not the two models had similar logical flows when approaching the vulnerability
2. **Implementation:** Complete Implementation of our Dynamic AI Task-Resolution Tree

**Current Status:** üü¢ On Track / üü° Minor Obstacles / üî¥ Blocked

üü¢ **On Track**: Set up the structure of the repository and began implementation of the multi-agent tree system.

üü° **Minor Obstacles**: 

üî¥ **Blocked**: 

---

## Key Accomplishments This Week

### 3 Academic Principles in the Repository
1. **Event Sourcing Pattern**

    <u>Definition</u>: For some Component A to call some Component B, Component A must publish an event that contains the call to Component B to the Event Queue. Then, Component B interacts with the Event Queue to get that call from Component A.

    <u>Intuition</u>: This event structure makes it easier to print logs. Events are appended to the Events Queue, then we can choose what logs to view. We could print out the entire Events Queue, or filter by a Component‚Äôs name, timestamp, etc.

    <u>Implementation Structure</u>: There are subclasses in the Event Queue class which represent different events that could happen, such as ChildSpawned or WorkCompleted. In the backend, the Event Queue is actually a Relational Database that we‚Äôre using PostgresSQL to access data from.
    
2. **Domain Driven Design**

    <u>Definition</u>: The functional logic of a system should not be specific to the database‚Äôs structure, it should be very general. This makes the system more modular and adaptable to different structures of data. Domain Driven Design distinguishes between our system's core logic and communication with an external system by abstracting functionality to not rely on specific data structures.

    <u>Implementation Structure</u>: Layout of our repository:
    - ‚ÄúCore‚Äù directory: has all python code to implement functionality. Within the "core" directory, there is another directory called "domain." The model.py file in ‚Äúdomain‚Äù is the core backbone of the whole system.
    - ‚ÄúInfrastructure‚Äù directory: has code to integreate models like Claude Code, OpenHands, etc, that are then used by the core functionality to create agents.

3. **Hexagonal Architecture**

    <u>Definition</u>: The purpose Hexagonal Architecture is to divide interfaces and implementations
   
    Composed of two parts:

    1. **Ports**: representing interfaces. These handle internal logic and functionality of our system. The ports are contained in the "core" directory, which is the core layer of the Domain Driven Design.
    2. **Adapters**: representing classes. These deal with knowledge of external systems. The adapters are contained in the "infrastructure" directory, which is the infrastructure layer of the Domain Driven Design.